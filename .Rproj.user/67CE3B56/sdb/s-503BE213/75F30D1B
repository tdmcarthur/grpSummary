{
    "collab_server" : "",
    "contents" : "#' Compares summary values of variables, split by defined groups\n#'\n#' This is a riveting description that describes what your function does. This\n#' is a link to \\code{\\link{hello}}.\n#'\n#' @param instructions.data A data frame on which to perform the summary.\n#' @param instructions.data A data frame. See 'Details'.\n#' @param factors.as.numeric TODO\n#' @param progress.bar logical. Whether to display a progress bar while calculations are being carried out.\n#'\n#' @details\n#' instructions.data is a dataframe with the following column names in the proper order:\n#' \"column\"       \"category\"     \"consolidate\"  \"exclude\"      \"quantile\"     \"use.function\"\n#' Each row deals with a different variable on which to split the data and perform the summary statistics.\n#' Typically, this dataframe would be created by reading in a csv file.\n#' The information in each column must conform to these specifications:\n#'\n#' * column: Must be the exact name of a column in the dataframe. This is the \"target column\"\n#' category: Must be either \"TRUE\" or \"FALSE\". Indicates whether the target column in the\n#' dataframe is a categorical variable or not.\n#'\n#' * consolidate: A set of categories in the target column to consolidate. separated by colons,\n#' pipes, and semicolons like in the following: WEST:California|Oregon|Nevada;EAST:New York|Virginia\n#'\n#' * exclude: Must be exact name(s) of categories in the target column that will be excluded when\n#' splitting the sample. Must be separated by semicolons, e.g. excluded.var.1;excluded.var.2;excluded.var.3\n#'\n#' * quantile: For numeric target columns, specify the quantile cut points to split the sample by.\n#' Quantiles must be separated by semicolons, e.g. .25;.5;.75\n#'\n#' * use.function: The name(s) of the R function(s) that will be applied to the data, separated by\n#' semicolons if more than one. Must be exactly as written in R. mean, sd, and median are known to\n#' work. Other functions are not guaranteed to work and may simply produce\n#' all NA's. na.rm=TRUE is automatically added as an argument to the\n#' function. Input example: mean;sd;median\n#'\n#' * cohen.d: Must be either \"TRUE\" or \"FALSE\". Indicates whether to calculate Cohen's d.\n#'\n#'\n#' @return Returns a matrix containing the results of the summary operations\n#' @export\n#'\n#' @seealso \\code{\\link{hello}}\n#'\n#' @examples\n#' adder(1, 2)\n#'\n#'\n#'\n#'\n\n# TODO: It would be a good idea to actually split up the factors into\n# different groups. See rpsychi::groupSummary and metabolomics::GroupSummary\n# See also cg package\n# Note: need to do:\n# source(\"http://www.bioconductor.org/biocLite.R\")\n# biocLite(\"limma\")\n# biocLite(\"pcaMethods\")\n# to get dependencies for metabolomics\n\n\n\ngrpSummary <- function(input.data, instructions.data,\n                       factors.as.numeric = TRUE, progress.bar = TRUE) {\n  options(warn = -1)\n  # Surpress warnings\n  # BEGIN checking that input data is correcty formatted\n\n  if (!is.data.frame(input.data)) stop(\"input.data must be a dataframe\")\n  if (!is.data.frame(instructions.data)) stop(\"instructions.data must be a dataframe\")\n\n  proper.column.names <- c(\"column\", \"category\", \"consolidate\",\n                           \"exclude\", \"quantile\", \"use.function\", \"cohen.d\")\n  if (!exists(\"cohen.d\")) {stop(\"Must load effsize package\")}\n\n  if (factors.as.numeric) {\n    column.factors <- list()\n    for ( i in colnames(input.data) ) {\n      if ( length(levels(input.data[, i])) == 0) {\n        column.factors[[i]] <- NA\n      } else {\n        column.factors[[i]] <- levels(input.data[, i])\n      }\n    }\n  }\n\n\n  for ( i in 1:ncol(input.data)) {\n    if ( is.factor(input.data[, i]) ) {\n      input.data[, i] <- as.character(input.data[, i])\n    }\n  }\n\n  for ( i in colnames(instructions.data)) {\n    if ( i != \"category\" ) {\n      instructions.data[, i] <- as.character(instructions.data[, i])\n      instructions.data[is.na(instructions.data[, i]), i] <- \"\"\n    }\n  }\n\n  if (! all(names(instructions.data)==proper.column.names)) {\n    stop(paste0(\"instructions.data column names must be: \", paste0(proper.column.names, collapse=\", \")))\n  }\n\n  if (! all(instructions.data$column %in% colnames(input.data) ) ) {\n    stop(\"A variable specified in the 'column' of instructions.data does not appear in input.data\")\n  }\n\n  if (! all(instructions.data$category %in% c(TRUE, FALSE) ) & is.logical(instructions.data$category) ) {\n    stop(\"Elements of the 'category' column of instructions.data must be either 'TRUE' or 'FALSE'\")\n  }\n\n    if (! all(instructions.data$cohen.d %in% c(TRUE, FALSE) ) & is.logical(instructions.data$cohen.d) ) {\n    stop(\"Elements of the 'cohen.d' column of instructions.data must be either 'TRUE' or 'FALSE'\")\n  }\n\n\n\n\n  for ( i in 1:nrow(instructions.data)) {\n\n\n    consol.temp <- instructions.data$consolidate[i]\n    # Grab the contents of the consolidate column\n\n    if ( consol.temp != \"\" & ! ( grepl(\"[:]\", consol.temp) & grepl(\"[|]\", consol.temp) ) ) {\n      stop(paste0(\"Something is wrong with the consolidate info for the \",\n                  instructions.data$column[i], \" variable\"))\n    }\n\n    intended.exclude.temp <- strsplit(instructions.data$exclude, \";\", fixed=TRUE)[[1]]\n    if (! (instructions.data$exclude[i] == \"\" ||\n           all(intended.exclude.temp %in% input.data[, instructions.data$column[i] ] ) )  ) {\n      stop(paste0(\"Intended excluded category \", instructions.data$exclude[i] ,\n                  \" does not appear in \", instructions.data$column[i], \" variable\"))\n    }\n\n\n    quantile.temp <- as.numeric(strsplit(instructions.data$quantile[i], \";\")[[1]])\n\n    if ( length(quantile.temp) > 0 ) {\n      if (! is.numeric(input.data[, instructions.data$column[i] ]) ) {\n        stop(\"Intended quantile variable \" , instructions.data$column[i], \" is not numeric\")\n      }\n    }\n\n    if ( any(is.na(quantile.temp)) || ! (all(quantile.temp < 1) & all(quantile.temp > 0)) ) {\n      stop(\"Something is wrong with the quantile specification for the \",\n           instructions.data$column[i], \" variable\")\n    }\n\n    funcs.to.apply.temp <- strsplit( instructions.data$use.function[i] , \";\")[[1]]\n    for ( j in funcs.to.apply.temp) {\n      if ( ! exists( j ) ) {\n        stop(\"Function \", j , \" intended for use on \",\n             instructions.data$column[i], \"does not exist in the workspace\")\n      }\n    }\n\n\n\n  }\n\n  # END checking that input data is correcty formatted\n\n\n\n  instructions.data <- as.data.frame( lapply(instructions.data, FUN = function(x) {\n    x[is.na(x)] <- \"\"\n    x\n  }), stringsAsFactors = FALSE )\n\n  # instructions.data <- instructions.data[1, , drop=FALSE]\n\n  final.mats.ls <- list()\n\n  # The below will only work for Stata files; if the input file is not a Stata file,\n  # then it will just result in a blank column in the output\n  final.mats.ls[[ length(final.mats.ls) + 1 ]] <- c(\"\", attr(input.data, \"var.labels\") )\n  if (factors.as.numeric) {\n    input.data.temp <- input.data\n    for ( i in colnames(input.data.temp)) {\n          if ( all(is.na( column.factors[[i]] )) ) { next }\n          input.data.temp[, i] <- factor(input.data.temp[, i], levels = column.factors[[i]])\n          input.data.temp[, i] <- as.numeric(input.data.temp[, i])\n    }\n    final.mats.ls[[ length(final.mats.ls) + 1 ]] <-\n      t( aggregate( input.data.temp, by = list( rep(\"TOTAL\", nrow(input.data.temp)) ),\n                  FUN = mean, na.rm = TRUE) )\n    rm(input.data.temp)\n  } else {\n    final.mats.ls[[ length(final.mats.ls) + 1 ]] <-\n      t( aggregate( input.data, by = list( rep(\"TOTAL\", nrow(input.data)) ),\n                  FUN = mean, na.rm = TRUE) )\n  }\n\n\n  final.mats.ls[[ length(final.mats.ls) + 1 ]] <-\n    t( aggregate( input.data, by = list( rep(\"N non-missing\", nrow(input.data)) ),\n                  FUN = function(x) { sum(!is.na(x)) } ))\n\n  if (progress.bar) {\n    cat(\"Progress: \\n\")\n    pb = txtProgressBar(min = 0, max = nrow(instructions.data), initial = 0, style = 3)\n  }\n\n  for (targ.split in 1:nrow(instructions.data) ) {\n\n    targ.instructions.data <- instructions.data[targ.split, , drop=FALSE]\n\n    category.T.F <- targ.instructions.data$category\n    # Simply capture what type of data we are dealing with -\n    # categorical or numeric\n\n    targ.col <- targ.instructions.data$column\n\n    working.df <- input.data\n    # Create a copy of the original dataset, since we may subset it\n\n    intended.exclude <- strsplit(targ.instructions.data$exclude, \";\", fixed=TRUE)[[1]]\n    # separating the categories that we want to exlude, if they exist\n    # Using the fact that we are denoting separate categories by semicolon\n\n    if (category.T.F) {\n\n      if ( length(intended.exclude) > 0 ) {\n        # If there is nothing in the \"exclude\" column in the\n        # split.info file, then length of intended.exclude is zero\n        working.df <- working.df[\n          ! working.df[, targ.instructions.data$column] %in% intended.exclude,\n          ]\n      }\n\n      consol <- targ.instructions.data$consolidate\n      # Grab the contents of the consolidate column\n\n      if ( consol != \"\" ) {\n\n        consol <- strsplit(consol, \";\", fixed=TRUE)[[1]]\n\n        for (targ.consol in consol) {\n\n          targ.consol <- strsplit(targ.consol, \":\", fixed=TRUE)[[1]]\n\n          to.be.consolidated <- strsplit(targ.consol[2], \"|\", fixed=TRUE)[[1]]\n\n          working.df[ working.df[, targ.col] %in% to.be.consolidated , targ.col] <-\n            targ.consol[1]\n\n        }\n\n      }\n\n    } else {\n      # So if it is not categorical, it will do the piece of code that is meant for\n      # quantiles\n\n      targ.quantiles  <- sort(c(0, as.numeric(strsplit(targ.instructions.data$quantile, \";\")[[1]]), 1))\n\n      quantile.temp <- quantile(working.df[, targ.col],\n               probs = targ.quantiles,\n               na.rm=TRUE)\n\n      #quantile.temp.fixed <- quantile.temp\n\n      targ.quantiles <- targ.quantiles[!duplicated(quantile.temp)]\n\n\n      working.df$temp.col.for.quant <- cut(working.df[, targ.col],\n                                           breaks = quantile(working.df[, targ.col],\n                                                             probs = targ.quantiles,\n                                                             na.rm=TRUE),\n                                           include.lowest=TRUE)\n\n      quantile.names <- c()\n      for ( i in 2:length(targ.quantiles)) {\n        quantile.names <- c(quantile.names,\n                            paste0(round(targ.quantiles[i-1] * 100), \"%-\",\n                                   round(targ.quantiles[i] * 100), \"%\") )\n      }\n\n\n\n      levels(working.df$temp.col.for.quant) <-\n        paste0(quantile.names, \":\", levels(working.df$temp.col.for.quant))\n\n      working.df$temp.col.for.quant <- as.character(working.df$temp.col.for.quant)\n\n      # Thanks to http://stackoverflow.com/questions/4126326/how-to-quickly-form-groups-quartiles-deciles-etc-by-ordering-columns-in-a\n\n    }\n\n\n    agg.column <- ifelse(category.T.F, targ.col, \"temp.col.for.quant\")\n\n    funcs.to.apply <- strsplit( targ.instructions.data$use.function , \";\")[[1]]\n\n    for ( targ.func in funcs.to.apply) {\n\n      trycatch.targ.func <- function(x, ...) {\n        func.name <- get(targ.func)\n        tryCatch(func.name(x, ...), error=function(e) NA )\n      }\n      # This above is a bit advanced\n\n      if ( all(intended.exclude!=\"nr\")  ) {\n        working.df[is.na( working.df[, agg.column] ), agg.column] <- \"NR/NA\"\n      }\n\n\n      working.df.save <- working.df\n\n      if (factors.as.numeric) {\n        for ( i in colnames(working.df)[! colnames(working.df) %in%\n                                        c( \"temp.col.for.quant\", agg.column) ]) {\n          if ( all(is.na( column.factors[[i]] )) ) { next }\n          working.df[, i] <- factor(working.df[, i], levels = column.factors[[i]])\n          working.df[, i] <- as.numeric(working.df[, i])\n        }\n      }\n\n      ret.agg <- aggregate( working.df[, colnames(working.df) != \"temp.col.for.quant\"],\n                            by = list(working.df[, agg.column]),\n                            FUN = trycatch.targ.func, na.rm = TRUE)\n\n      ret.agg[, 1] <- paste0(targ.func, \":\", targ.col, \":\", ret.agg[, 1])\n\n      final.mats.ls[[ length(final.mats.ls) + 1 ]] <- t(ret.agg)\n\n      if ( targ.func == \"mean\" ) {\n\n        unique.cats <- unique(working.df[, agg.column])\n\n        if ( length(unique.cats ) == 2 ) {\n\n          ttest.logic.v <- working.df[, agg.column] == unique.cats[1]\n          # Careful with missings....\n          # [, \"services1\", drop=FALSE]\n          test.vec <- sapply(working.df[, colnames(working.df) != \"temp.col.for.quant\"],\n                             FUN = function(x) {\n            # cat(\"one\", \"\\n\")\n            if (sum(!is.na(x)) < 2) { return(NA) }\n            if (is.factor(x) | is.character(x)) {\n              tryCatch(chisq.test(table(x, ttest.logic.v))$p.value,\n                       error = function(e) NA)\n\n            } else {\n              tryCatch(t.test(x =  x[  ttest.logic.v],\n                              y =  x[! ttest.logic.v] )$p.value,\n                       error = function(e) NA)\n            }\n          } )\n\n          test.vec[sapply(test.vec, length)==0] <- NA\n          test.vec <- unlist(test.vec)\n\n        } else {\n\n          #print(str(working.df))\n          test.vec <- sapply(working.df[, colnames(working.df) != \"temp.col.for.quant\"],\n                             FUN = function(x) {\n            # cat(\"one\", \"\\n\")\n            if (sum(!is.na(x)) < 2) { return(NA) }\n            if (is.factor(x) | is.character(x)) {\n              tryCatch(chisq.test(table(x, ttest.logic.v))$p.value,\n                       error = function(e) NA)\n\n            } else {\n            tryCatch(\n              summary(\n                aov(as.formula(paste0(\"x ~ working.df[, agg.column]\")) )\n              )[[1]]$`Pr(>F)`[1]\n              ,\n              error = function(e) NA)\n            }\n          } )\n          test.vec[sapply(test.vec, length)==0] <- NA\n          test.vec <- unlist(test.vec)\n\n        }\n\n        test.vec <- test.vec[names(test.vec)!=\"temp.col.for.quant\"]\n        test.stars <- vector(mode=\"character\", length=length(test.vec))\n\n        test.stars[test.vec < .1 ] <- \"*\"\n        test.stars[test.vec < .05 ] <- \"**\"\n        test.stars[test.vec < .01 ] <- \"***\"\n\n        final.mats.ls[[ length(final.mats.ls) + 1 ]] <- c(\"eq.means.test\", test.vec)\n        final.mats.ls[[ length(final.mats.ls) + 1 ]] <- c(\"eq.means.stars\", test.stars)\n        working.df <- working.df.save\n      }\n\n    }\n\n    do.cohen.d <- targ.instructions.data$cohen.d\n\n    if (do.cohen.d) {\n\n      unique.cats <- unique(working.df[, agg.column])\n      cats.grid <- t(combn(unique.cats, 2))\n      #cohen.mat.ls <- list()\n      for ( i in 1:nrow(cats.grid)) {\n        cohen.d.logic.v.1 <- working.df[, agg.column] == cats.grid[i, 1]\n        cohen.d.logic.v.2 <- working.df[, agg.column] == cats.grid[i, 2]\n        cohen.mat <- sapply(working.df[, colnames(working.df) != \"temp.col.for.quant\"],\n          FUN = function(x) {\n          if (sum(!is.na(x)) < 2) {\n            ret <- list(estimate=NA, conf.int=c(NA, NA))\n           # cat(\"NAs\\n\")\n          } else {\n\n            ret <- tryCatch(effsize::cohen.d(na.omit(x[cohen.d.logic.v.1]), na.omit(x[cohen.d.logic.v.2])),\n                       error = function(e) list(estimate=NA, conf.int=c(NA, NA))\n            )\n            #cat(\"Calced cohens \\n\")\n          }\n          #print(ret)\n           ret$conf.int <- paste0(\"(\", ret$conf.int[1], \", \", ret$conf.int[2], \")\")\n           c(ret$estimate, ret$conf.int)\n        } )\n        cohen.name <- paste0(cats.grid[i, 1], \" | \", cats.grid[i, 2])\n        cohen.mat <- t(cohen.mat)\n        colnames.cohen.mat <- c(paste0(\"cohen.est: \", cohen.name),\n                                 paste0(\"cohen.conf.int: \", cohen.name))\n        cohen.mat <- rbind(colnames.cohen.mat, cohen.mat)\n        final.mats.ls[[ length(final.mats.ls) + 1 ]] <- cohen.mat\n        #cohen.mat.ls[[i]] <- cohen.mat\n      }\n      #cohen.mat.binded <- do.call(cbind, cohen.mat.ls)\n      #final.mats.ls[[ length(final.mats.ls) + 1 ]] do.call(cbind, cohen.mat.ls)\n\n    }\n\n\n    if (progress.bar) { setTxtProgressBar(pb, targ.split) }\n  }\n\n\n\n  final.ret <- do.call(cbind, final.mats.ls)\n  options(warn = 0)\n\n  final.ret\n\n}\n\n\n\n\n\n\n# The function will raise a bunch of warnings because some of the\n# test statistics can't be calculated with all of the variables,\n# e.g. when the sample variance is zero.\n# So warnings are surpressed within the function\n\n",
    "created" : 1464555709358.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4071510267",
    "id" : "75F30D1B",
    "lastKnownWriteTime" : 1464558243,
    "last_content_update" : 1464558243327,
    "path" : "~/git/grpSummary/R/grpSummary.r",
    "project_path" : "R/grpSummary.r",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}